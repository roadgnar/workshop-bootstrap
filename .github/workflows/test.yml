name: Test Bootstrap

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:  # Allow manual trigger

jobs:
  # ============================================
  # Linux Testing - FULL DOCKER TESTS
  # ============================================
  # This is the primary test environment. Docker runs natively on Linux
  # runners, so we can fully test the container build, run, and endpoints.
  test-linux:
    name: üêß Linux (Full Docker Tests)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: |
          chmod +x linux/bootstrap linux/dev
          chmod +x scripts/*.sh
          chmod +x repos/*/scripts/*.sh

      # ----------------------------------------
      # Test 1: Verify Docker is pre-installed
      # ----------------------------------------
      - name: "Test 1: Docker pre-installed on runner"
        run: |
          echo "==> Checking Docker installation..."
          docker --version
          docker compose version
          echo "‚úì Docker and Compose are available"

      # ----------------------------------------
      # Test 2: Detection functions work
      # ----------------------------------------
      - name: "Test 2: Detection functions"
        run: |
          export OS="linux"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          echo "==> Testing detection functions..."
          
          docker_installed && echo "‚úì docker_installed() works" || exit 1
          docker_running && echo "‚úì docker_running() works" || exit 1
          compose_available && echo "‚úì compose_available() works" || exit 1

      # ----------------------------------------
      # Test 2.5: Port management functions
      # ----------------------------------------
      - name: "Test 2.5: Port management functions"
        run: |
          export OS="linux"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          echo "==> Testing port management functions..."
          
          # Test port_in_use on a port that should be free
          if port_in_use 59999; then
            echo "‚úó port_in_use returned true for unused port"
            exit 1
          fi
          echo "‚úì port_in_use() correctly detects free port"
          
          # Start a temporary server to test port detection
          python3 -m http.server 59998 &
          SERVER_PID=$!
          sleep 1
          
          if port_in_use 59998; then
            echo "‚úì port_in_use() correctly detects used port"
          else
            echo "‚úó port_in_use failed to detect used port"
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi
          
          # Test get_port_process
          PID=$(get_port_process 59998)
          if [[ -n "$PID" ]]; then
            echo "‚úì get_port_process() returns PID: $PID"
          else
            echo "‚úó get_port_process() failed"
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi
          
          # Cleanup
          kill $SERVER_PID 2>/dev/null || true
          echo "‚úì Port management functions work correctly"

      # ----------------------------------------
      # Test 3: Build container image
      # ----------------------------------------
      - name: "Test 3: Build container image"
        run: |
          echo "==> Building development container..."
          docker compose build dev
          echo "‚úì Container image built successfully"

      # ----------------------------------------
      # Test 4: Start container
      # ----------------------------------------
      - name: "Test 4: Start container"
        run: |
          echo "==> Starting container..."
          docker compose up -d dev
          sleep 3
          
          echo "==> Verifying container is running..."
          docker compose ps
          
          # Check container is actually running
          if docker compose ps --status running | grep -q "workshop-dev"; then
            echo "‚úì Container is running"
          else
            echo "‚úó Container failed to start"
            docker compose logs
            exit 1
          fi

      # ----------------------------------------
      # Test 5: Verify bind mount works
      # ----------------------------------------
      - name: "Test 5: Bind mount verification"
        run: |
          echo "==> Testing bind mount (host files accessible in container)..."
          
          # Check that repo files are accessible inside container
          docker compose exec dev ls -la /workspace/
          docker compose exec dev cat /workspace/README.md | head -5
          
          # Verify repos directory structure
          docker compose exec dev ls -la /workspace/repos/
          docker compose exec dev ls -la /workspace/repos/demo-site/
          
          # Create a test file on host, verify it appears in container
          echo "test-from-host-$(date +%s)" > test-bind-mount.txt
          docker compose exec dev cat /workspace/test-bind-mount.txt
          rm test-bind-mount.txt
          
          echo "‚úì Bind mount working correctly"

      # ----------------------------------------
      # Test 6: Install demo-site dependencies
      # ----------------------------------------
      - name: "Test 6: Install demo-site dependencies"
        run: |
          echo "==> Installing demo-site dependencies..."
          docker compose exec dev bash -c "/workspace/scripts/start-repo.sh install demo-site"
          echo "‚úì Dependencies installed"

      # ----------------------------------------
      # Test 7: Start demo-site service
      # ----------------------------------------
      - name: "Test 7: Start demo-site service"
        run: |
          echo "==> Starting demo-site service..."
          docker compose exec -d dev bash -c "/workspace/scripts/start-repo.sh demo-site start"
          
          echo "==> Waiting for service to be ready..."
          
          # Wait for the service to respond
          for i in {1..15}; do
            if curl -sf http://localhost:8080/health > /dev/null 2>&1; then
              echo "‚úì Demo service started and responding"
              exit 0
            fi
            echo "Waiting... ($i/15)"
            sleep 2
          done
          
          echo "‚úó Demo service not responding after 30 seconds"
          docker compose exec dev cat /workspace/logs/demo-site.log || true
          docker compose logs dev
          exit 1

      # ----------------------------------------
      # Test 8: Health endpoint from HOST
      # ----------------------------------------
      - name: "Test 8: Health check from HOST (outside container)"
        run: |
          echo "==> Pinging health endpoint from HOST machine..."
          
          HEALTH_RESPONSE=$(curl -sf http://localhost:8080/health)
          echo "Response: $HEALTH_RESPONSE"
          
          # Validate JSON structure
          echo "$HEALTH_RESPONSE" | jq -e '.status == "healthy"' || {
            echo "‚úó Health check failed - status not 'healthy'"
            exit 1
          }
          
          echo "$HEALTH_RESPONSE" | jq -e '.version' || {
            echo "‚úó Health check failed - missing version"
            exit 1
          }
          
          echo "‚úì Health endpoint responds correctly from host"

      # ----------------------------------------
      # Test 9: Main page from HOST
      # ----------------------------------------
      - name: "Test 9: Main page from HOST"
        run: |
          echo "==> Fetching main page from HOST..."
          
          HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:8080/)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úì Main page returns 200 OK"
          else
            echo "‚úó Main page returned $HTTP_CODE"
            exit 1
          fi
          
          # Verify it contains expected content
          curl -sf http://localhost:8080/ | grep -q "It Works" || {
            echo "‚úó Main page doesn't contain expected content"
            exit 1
          }
          
          echo "‚úì Main page content verified"

      # ----------------------------------------
      # Test 10: API info endpoint from HOST
      # ----------------------------------------
      - name: "Test 10: API info endpoint from HOST"
        run: |
          echo "==> Testing API info endpoint..."
          
          INFO_RESPONSE=$(curl -sf http://localhost:8080/api/info)
          echo "Response: $INFO_RESPONSE"
          
          # Validate required fields exist
          echo "$INFO_RESPONSE" | jq -e '.version' || exit 1
          echo "$INFO_RESPONSE" | jq -e '.hostname' || exit 1
          echo "$INFO_RESPONSE" | jq -e '.server_time' || exit 1
          
          echo "‚úì API info endpoint works correctly"

      # ----------------------------------------
      # Test 11: Dev helper commands
      # ----------------------------------------
      - name: "Test 11: Dev helper commands"
        run: |
          cd linux
          
          echo "==> Testing ./dev status..."
          ./dev status
          
          echo "==> Testing ./dev list..."
          ./dev list
          
          echo "‚úì Dev helper commands work"

      # ----------------------------------------
      # Test 12: Stop demo-site service
      # ----------------------------------------
      - name: "Test 12: Stop demo-site service"
        run: |
          echo "==> Stopping demo-site service..."
          docker compose exec dev bash -c "/workspace/scripts/start-repo.sh demo-site stop"
          echo "‚úì Service stopped"

      # ----------------------------------------
      # Cleanup
      # ----------------------------------------
      - name: Cleanup
        if: always()
        run: |
          docker compose down --volumes --remove-orphans || true

  # ============================================
  # macOS Testing
  # ============================================
  # GitHub Actions macOS runners don't support nested virtualization,
  # so Docker daemon cannot run. We test:
  # - Script syntax and functions
  # - Docker CLI installation (daemon won't work)
  # - Cursor installation
  test-macos:
    name: üçé macOS (Scripts + Install Tests)
    runs-on: macos-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: |
          chmod +x mac/bootstrap mac/dev
          chmod +x scripts/*.sh
          chmod +x repos/*/scripts/*.sh

      # ----------------------------------------
      # Script Tests
      # ----------------------------------------
      - name: "Test 1: Utility functions"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          print_banner
          log_step "Testing utility functions..."
          log_info "Info message test"
          log_success "Success message test"
          log_warn "Warning message test"
          print_separator
          echo "‚úì Utility functions work"

      - name: "Test 2: Detection functions"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          # Test OS detection
          detected_os=$(detect_os)
          [[ "$detected_os" == "macos" ]] && echo "‚úì OS detection works" || exit 1
          
          # Test command_exists
          command_exists bash && echo "‚úì command_exists works" || exit 1

      - name: "Test 2.5: Port management functions"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          echo "==> Testing port management functions..."
          
          # Test port_in_use on a port that should be free
          if port_in_use 59999; then
            echo "‚úó port_in_use returned true for unused port"
            exit 1
          fi
          echo "‚úì port_in_use() correctly detects free port"
          
          # Start a temporary server to test port detection
          python3 -m http.server 59998 &
          SERVER_PID=$!
          
          # macOS may need more time for the server to start listening
          sleep 3
          
          # Debug: show what lsof sees
          echo "Debug: lsof output for port 59998:"
          lsof -nP -iTCP:59998 2>/dev/null || echo "(no output)"
          
          if port_in_use 59998; then
            echo "‚úì port_in_use() correctly detects used port"
          else
            echo "‚úó port_in_use failed to detect used port"
            echo "Debug: get_port_process returned: '$(get_port_process 59998)'"
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi
          
          # Cleanup
          kill $SERVER_PID 2>/dev/null || true
          echo "‚úì Port management functions work correctly"

      - name: "Test 3: Script syntax validation"
        run: |
          echo "==> Checking all bash scripts..."
          bash -n mac/bootstrap && echo "‚úì mac/bootstrap"
          bash -n mac/dev && echo "‚úì mac/dev"
          for f in scripts/*.sh; do
            bash -n "$f" && echo "‚úì $f"
          done
          for f in repos/*/scripts/*.sh; do
            bash -n "$f" && echo "‚úì $f"
          done

      # ----------------------------------------
      # Docker CLI Installation Test
      # ----------------------------------------
      - name: "Test 4: Install Docker CLI via Homebrew"
        run: |
          echo "==> Installing Docker CLI (not Desktop)..."
          brew install docker docker-compose
          
          echo "==> Verifying Docker CLI installed..."
          docker --version
          
          echo "==> Verifying docker-compose installed..."
          docker-compose --version
          
          echo "‚úì Docker CLI and docker-compose installed successfully"
          echo "Note: Daemon cannot run (no nested virtualization)"

      - name: "Test 5: Docker detection after install"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          if docker_installed; then
            echo "‚úì docker_installed() correctly detects Docker CLI"
          else
            echo "‚úó docker_installed() failed to detect Docker"
            exit 1
          fi
          
          if compose_available; then
            echo "‚úì compose_available() correctly detects docker-compose"
          else
            echo "‚úó compose_available() failed to detect docker-compose"
            exit 1
          fi
          
          # Daemon won't be running, that's expected
          if ! docker_running; then
            echo "‚úì docker_running() correctly reports daemon not running (expected)"
          fi

      # ----------------------------------------
      # Cursor Installation Test - USES ACTUAL SCRIPT
      # ----------------------------------------
      - name: "Test 6: Install Cursor using ACTUAL install script"
        run: |
          echo "==> Calling install_cursor_macos from actual script..."
          
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          source scripts/install-cursor-macos.sh
          
          # Call the ACTUAL install function
          install_cursor_macos
          
          echo "‚úì install_cursor_macos completed successfully"

      - name: "Test 7: Cursor detection after install"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          source scripts/install-cursor-macos.sh
          
          if detect_cursor_macos; then
            echo "‚úì detect_cursor_macos() correctly detects Cursor"
          else
            echo "‚úó detect_cursor_macos() failed to detect Cursor"
            exit 1
          fi
          
          echo "==> Verifying Cursor installed..."
          ls -la /Applications/Cursor.app || ls -la ~/Applications/Cursor.app || echo "Cursor.app not in expected location"

      - name: "Test 8: Dev helper commands"
        run: |
          cd mac
          echo "==> Testing ./dev list..."
          ./dev list
          echo "‚úì Dev helper commands work"

  # ============================================
  # Windows Testing
  # ============================================
  # GitHub Actions Windows runners use Windows containers by default.
  # Our Dockerfile is Linux-based, so Docker daemon can't run containers.
  # We test:
  # - Script syntax and functions
  # - Docker CLI installation (daemon won't work with Linux containers)
  # - Cursor installation
  test-windows:
    name: ü™ü Windows (Scripts + Install Tests)
    runs-on: windows-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ----------------------------------------
      # Script Tests
      # ----------------------------------------
      - name: "Test 1: PowerShell utilities"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          
          Write-Banner
          Write-Step "Testing utility functions..."
          Write-Info "Info message test"
          Write-Success "Success message test"
          Write-Warn "Warning message test"
          Write-Separator
          Write-Host "‚úì Utility functions work"

      - name: "Test 2: Detection functions"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          
          if (Test-CommandExists "powershell") {
            Write-Host "‚úì Test-CommandExists works"
          } else {
            Write-Host "‚úó Test-CommandExists failed"
            exit 1
          }

      - name: "Test 2.5: Port management functions"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          
          Write-Host "==> Testing port management functions..."
          
          # Test Test-PortInUse on a port that should be free
          if (Test-PortInUse -Port 59999) {
            Write-Host "‚úó Test-PortInUse returned true for unused port"
            exit 1
          }
          Write-Host "‚úì Test-PortInUse correctly detects free port"
          
          # Start a temporary listener to test port detection
          $listener = [System.Net.Sockets.TcpListener]::new([System.Net.IPAddress]::Any, 59998)
          $listener.Start()
          
          if (Test-PortInUse -Port 59998) {
            Write-Host "‚úì Test-PortInUse correctly detects used port"
          } else {
            Write-Host "‚úó Test-PortInUse failed to detect used port"
            $listener.Stop()
            exit 1
          }
          
          # Test Get-PortProcess
          $process = Get-PortProcess -Port 59998
          if ($process) {
            Write-Host "‚úì Get-PortProcess returns process: $($process.ProcessName)"
          } else {
            Write-Host "‚ö† Get-PortProcess returned null (may need elevated privileges)"
          }
          
          # Cleanup
          $listener.Stop()
          Write-Host "‚úì Port management functions work correctly"

      - name: "Test 3: Script syntax validation"
        shell: pwsh
        run: |
          $scripts = @(
            ".\windows\bootstrap.ps1",
            ".\windows\dev.ps1",
            ".\scripts\utils.ps1",
            ".\scripts\install-docker-windows.ps1",
            ".\scripts\install-cursor-windows.ps1"
          )
          
          foreach ($script in $scripts) {
            $errors = $null
            $null = [System.Management.Automation.PSParser]::Tokenize(
              (Get-Content -Path $script -Raw), 
              [ref]$errors
            )
            if ($errors.Count -eq 0) {
              Write-Host "‚úì $script syntax OK"
            } else {
              Write-Host "‚úó $script has syntax errors"
              $errors | ForEach-Object { Write-Host $_ }
              exit 1
            }
          }

      # ----------------------------------------
      # Docker Tests (pre-installed on Windows runner)
      # ----------------------------------------
      - name: "Test 4: Verify Docker (pre-installed)"
        shell: pwsh
        run: |
          Write-Host "==> Checking Docker (pre-installed on runner)..."
          docker --version
          docker compose version
          Write-Host "‚úì Docker CLI is available"
          Write-Host "Note: Daemon runs Windows containers, not compatible with our Linux Dockerfile"

      - name: "Test 5: Docker detection functions"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          
          if (Test-DockerInstalled) {
            Write-Host "‚úì Test-DockerInstalled correctly detects Docker"
          } else {
            Write-Host "‚úó Test-DockerInstalled failed"
            exit 1
          }
          
          if (Test-ComposeAvailable) {
            Write-Host "‚úì Test-ComposeAvailable correctly detects Docker Compose"
          } else {
            Write-Host "‚úó Test-ComposeAvailable failed"
            exit 1
          }
          
          # Note: Docker daemon IS running on Windows runners, but with Windows containers
          Write-Host "Docker daemon status: $(Test-DockerRunning)"

      # ----------------------------------------
      # Cursor Installation Test - USES ACTUAL SCRIPT
      # ----------------------------------------
      - name: "Test 6: Install Cursor using ACTUAL install script"
        shell: pwsh
        run: |
          Write-Host "==> Calling Install-CursorWindows from actual script..."
          
          # Source the ACTUAL install script
          . .\scripts\utils.ps1
          . .\scripts\install-cursor-windows.ps1
          
          # Call the ACTUAL install function
          $result = Install-CursorWindows
          
          if ($result) {
            Write-Host "‚úì Install-CursorWindows completed successfully"
          } else {
            Write-Host "‚úó Install-CursorWindows failed"
            exit 1
          }

      - name: "Test 7: Verify Cursor detection after install"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          . .\scripts\install-cursor-windows.ps1
          
          Write-Host "==> Testing Cursor detection after install..."
          
          # Check if Cursor is detected
          if (Test-CursorInstalled) {
            Write-Host "‚úì Test-CursorInstalled correctly detects Cursor"
          } else {
            Write-Host "‚úó Test-CursorInstalled failed to detect Cursor"
            exit 1
          }
          
          # Test the Get-CursorPath function
          $path = Get-CursorPath
          if ($path) {
            Write-Host "‚úì Cursor found at: $path"
          } else {
            Write-Host "‚ö† Get-CursorPath returned null (may need PATH refresh)"
          }

      - name: "Test 8: Dev helper commands"
        shell: pwsh
        run: |
          Set-Location windows
          Write-Host "Current directory: $(Get-Location)"
          Write-Host "Files in directory:"
          Get-ChildItem -Name
          Write-Host ""
          Write-Host "Running: .\dev.ps1 list"
          & .\dev.ps1 list
          Write-Host "‚úì Dev helper commands work"

  # ============================================
  # Summary Job
  # ============================================
  test-summary:
    name: ‚úÖ All Tests Passed
    needs: [test-linux, test-macos, test-windows]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Check results
        run: |
          if [ "${{ needs.test-linux.result }}" != "success" ]; then
            echo "‚ùå Linux tests failed"
            exit 1
          fi
          if [ "${{ needs.test-macos.result }}" != "success" ]; then
            echo "‚ùå macOS tests failed"
            exit 1
          fi
          if [ "${{ needs.test-windows.result }}" != "success" ]; then
            echo "‚ùå Windows tests failed"
            exit 1
          fi
          echo "‚úÖ All platform tests passed!"
