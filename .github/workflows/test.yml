name: Test Bootstrap

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:  # Allow manual trigger

jobs:
  # ============================================
  # Linux Testing - FULL DOCKER TESTS
  # ============================================
  # This is the primary test environment. Docker runs natively on Linux
  # runners, so we can fully test the container build, run, and endpoints.
  test-linux:
    name: üêß Linux (Full Docker Tests)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: |
          chmod +x linux/bootstrap linux/dev
          chmod +x scripts/*.sh

      # ----------------------------------------
      # Test 1: Verify Docker is pre-installed
      # ----------------------------------------
      - name: "Test 1: Docker pre-installed on runner"
        run: |
          echo "==> Checking Docker installation..."
          docker --version
          docker compose version
          echo "‚úì Docker and Compose are available"

      # ----------------------------------------
      # Test 2: Detection functions work
      # ----------------------------------------
      - name: "Test 2: Detection functions"
        run: |
          export OS="linux"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          echo "==> Testing detection functions..."
          
          docker_installed && echo "‚úì docker_installed() works" || exit 1
          docker_running && echo "‚úì docker_running() works" || exit 1
          compose_available && echo "‚úì compose_available() works" || exit 1

      # ----------------------------------------
      # Test 3: Build container image
      # ----------------------------------------
      - name: "Test 3: Build container image"
        run: |
          echo "==> Building development container..."
          docker compose build dev
          echo "‚úì Container image built successfully"

      # ----------------------------------------
      # Test 4: Start container
      # ----------------------------------------
      - name: "Test 4: Start container"
        run: |
          echo "==> Starting container..."
          docker compose up -d dev
          sleep 3
          
          echo "==> Verifying container is running..."
          docker compose ps
          
          # Check container is actually running
          if docker compose ps --status running | grep -q "workshop-dev"; then
            echo "‚úì Container is running"
          else
            echo "‚úó Container failed to start"
            docker compose logs
            exit 1
          fi

      # ----------------------------------------
      # Test 5: Verify bind mount works
      # ----------------------------------------
      - name: "Test 5: Bind mount verification"
        run: |
          echo "==> Testing bind mount (host files accessible in container)..."
          
          # Check that repo files are accessible inside container
          docker compose exec dev ls -la /workspace/
          docker compose exec dev cat /workspace/README.md | head -5
          
          # Create a test file on host, verify it appears in container
          echo "test-from-host-$(date +%s)" > test-bind-mount.txt
          docker compose exec dev cat /workspace/test-bind-mount.txt
          rm test-bind-mount.txt
          
          echo "‚úì Bind mount working correctly"

      # ----------------------------------------
      # Test 6: Start demo web service
      # ----------------------------------------
      - name: "Test 6: Start demo service inside container"
        run: |
          echo "==> Starting Flask demo service..."
          docker compose exec -d dev bash -c "cd /workspace/demo-site && python app.py"
          
          echo "==> Waiting for service to be ready..."
          
          # Wait for the service to respond (more reliable than checking process)
          for i in {1..15}; do
            if curl -sf http://localhost:8080/health > /dev/null 2>&1; then
              echo "‚úì Demo service started and responding"
              exit 0
            fi
            echo "Waiting... ($i/15)"
            sleep 2
          done
          
          echo "‚úó Demo service not responding after 30 seconds"
          docker compose logs dev
          exit 1

      # ----------------------------------------
      # Test 7: Health endpoint from HOST
      # ----------------------------------------
      - name: "Test 7: Health check from HOST (outside container)"
        run: |
          echo "==> Pinging health endpoint from HOST machine..."
          
          HEALTH_RESPONSE=$(curl -sf http://localhost:8080/health)
          echo "Response: $HEALTH_RESPONSE"
          
          # Validate JSON structure
          echo "$HEALTH_RESPONSE" | jq -e '.status == "healthy"' || {
            echo "‚úó Health check failed - status not 'healthy'"
            exit 1
          }
          
          echo "$HEALTH_RESPONSE" | jq -e '.version' || {
            echo "‚úó Health check failed - missing version"
            exit 1
          }
          
          echo "‚úì Health endpoint responds correctly from host"

      # ----------------------------------------
      # Test 8: Main page from HOST
      # ----------------------------------------
      - name: "Test 8: Main page from HOST"
        run: |
          echo "==> Fetching main page from HOST..."
          
          HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:8080/)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úì Main page returns 200 OK"
          else
            echo "‚úó Main page returned $HTTP_CODE"
            exit 1
          fi
          
          # Verify it contains expected content
          curl -sf http://localhost:8080/ | grep -q "It Works" || {
            echo "‚úó Main page doesn't contain expected content"
            exit 1
          }
          
          echo "‚úì Main page content verified"

      # ----------------------------------------
      # Test 9: API info endpoint from HOST
      # ----------------------------------------
      - name: "Test 9: API info endpoint from HOST"
        run: |
          echo "==> Testing API info endpoint..."
          
          INFO_RESPONSE=$(curl -sf http://localhost:8080/api/info)
          echo "Response: $INFO_RESPONSE"
          
          # Validate required fields exist
          echo "$INFO_RESPONSE" | jq -e '.version' || exit 1
          echo "$INFO_RESPONSE" | jq -e '.hostname' || exit 1
          echo "$INFO_RESPONSE" | jq -e '.server_time' || exit 1
          
          echo "‚úì API info endpoint works correctly"

      # ----------------------------------------
      # Test 10: Dev helper commands
      # ----------------------------------------
      - name: "Test 10: Dev helper commands"
        run: |
          cd linux
          
          echo "==> Testing ./dev status..."
          ./dev status
          
          echo "==> Testing ./dev logs (brief)..."
          timeout 3 ./dev logs || true
          
          echo "‚úì Dev helper commands work"

      # ----------------------------------------
      # Cleanup
      # ----------------------------------------
      - name: Cleanup
        if: always()
        run: |
          docker compose down --volumes --remove-orphans || true

  # ============================================
  # macOS Testing
  # ============================================
  # GitHub Actions macOS runners don't support nested virtualization,
  # so Docker daemon cannot run. We test:
  # - Script syntax and functions
  # - Docker CLI installation (daemon won't work)
  # - Cursor installation
  test-macos:
    name: üçé macOS (Scripts + Install Tests)
    runs-on: macos-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: |
          chmod +x mac/bootstrap mac/dev
          chmod +x scripts/*.sh

      # ----------------------------------------
      # Script Tests
      # ----------------------------------------
      - name: "Test 1: Utility functions"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          print_banner
          log_step "Testing utility functions..."
          log_info "Info message test"
          log_success "Success message test"
          log_warn "Warning message test"
          print_separator
          echo "‚úì Utility functions work"

      - name: "Test 2: Detection functions"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          # Test OS detection
          detected_os=$(detect_os)
          [[ "$detected_os" == "macos" ]] && echo "‚úì OS detection works" || exit 1
          
          # Test command_exists
          command_exists bash && echo "‚úì command_exists works" || exit 1

      - name: "Test 3: Script syntax validation"
        run: |
          echo "==> Checking all bash scripts..."
          bash -n mac/bootstrap && echo "‚úì mac/bootstrap"
          bash -n mac/dev && echo "‚úì mac/dev"
          for f in scripts/*.sh; do
            bash -n "$f" && echo "‚úì $f"
          done

      # ----------------------------------------
      # Docker CLI Installation Test
      # ----------------------------------------
      - name: "Test 4: Install Docker CLI via Homebrew"
        run: |
          echo "==> Installing Docker CLI (not Desktop)..."
          brew install docker docker-compose
          
          echo "==> Verifying Docker CLI installed..."
          docker --version
          
          echo "==> Verifying docker-compose installed..."
          # Homebrew installs standalone docker-compose (with hyphen)
          docker-compose --version
          
          echo "‚úì Docker CLI and docker-compose installed successfully"
          echo "Note: Daemon cannot run (no nested virtualization)"

      - name: "Test 5: Docker detection after install"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          
          if docker_installed; then
            echo "‚úì docker_installed() correctly detects Docker CLI"
          else
            echo "‚úó docker_installed() failed to detect Docker"
            exit 1
          fi
          
          if compose_available; then
            echo "‚úì compose_available() correctly detects docker-compose"
          else
            echo "‚úó compose_available() failed to detect docker-compose"
            exit 1
          fi
          
          # Daemon won't be running, that's expected
          if ! docker_running; then
            echo "‚úì docker_running() correctly reports daemon not running (expected)"
          fi

      # ----------------------------------------
      # Cursor Installation Test
      # ----------------------------------------
      - name: "Test 6: Install Cursor via Homebrew"
        run: |
          echo "==> Installing Cursor IDE..."
          brew install --cask cursor
          
          echo "==> Verifying Cursor installed..."
          ls -la /Applications/Cursor.app || ls -la ~/Applications/Cursor.app
          
          echo "‚úì Cursor installed successfully"

      - name: "Test 7: Cursor detection after install"
        run: |
          export OS="macos"
          export SCRIPT_DIR="$(pwd)"
          source scripts/utils.sh
          source scripts/install-cursor-macos.sh
          
          if detect_cursor_macos; then
            echo "‚úì detect_cursor_macos() correctly detects Cursor"
          else
            echo "‚úó detect_cursor_macos() failed to detect Cursor"
            exit 1
          fi

      - name: "Test 8: Dev helper commands"
        run: |
          cd mac
          ./dev help
          echo "‚úì Dev help command works"

  # ============================================
  # Windows Testing
  # ============================================
  # GitHub Actions Windows runners use Windows containers by default.
  # Our Dockerfile is Linux-based, so Docker daemon can't run containers.
  # We test:
  # - Script syntax and functions
  # - Docker CLI installation (daemon won't work with Linux containers)
  # - Cursor installation
  test-windows:
    name: ü™ü Windows (Scripts + Install Tests)
    runs-on: windows-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ----------------------------------------
      # Script Tests
      # ----------------------------------------
      - name: "Test 1: PowerShell utilities"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          
          Write-Banner
          Write-Step "Testing utility functions..."
          Write-Info "Info message test"
          Write-Success "Success message test"
          Write-Warn "Warning message test"
          Write-Separator
          Write-Host "‚úì Utility functions work"

      - name: "Test 2: Detection functions"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          
          if (Test-CommandExists "powershell") {
            Write-Host "‚úì Test-CommandExists works"
          } else {
            Write-Host "‚úó Test-CommandExists failed"
            exit 1
          }

      - name: "Test 3: Script syntax validation"
        shell: pwsh
        run: |
          $scripts = @(
            ".\windows\bootstrap.ps1",
            ".\windows\dev.ps1",
            ".\scripts\utils.ps1",
            ".\scripts\install-docker-windows.ps1",
            ".\scripts\install-cursor-windows.ps1"
          )
          
          foreach ($script in $scripts) {
            $errors = $null
            $null = [System.Management.Automation.PSParser]::Tokenize(
              (Get-Content -Path $script -Raw), 
              [ref]$errors
            )
            if ($errors.Count -eq 0) {
              Write-Host "‚úì $script syntax OK"
            } else {
              Write-Host "‚úó $script has syntax errors"
              $errors | ForEach-Object { Write-Host $_ }
              exit 1
            }
          }

      # ----------------------------------------
      # Docker Tests (pre-installed on Windows runner)
      # ----------------------------------------
      - name: "Test 4: Verify Docker (pre-installed)"
        shell: pwsh
        run: |
          Write-Host "==> Checking Docker (pre-installed on runner)..."
          docker --version
          docker compose version
          Write-Host "‚úì Docker CLI is available"
          Write-Host "Note: Daemon runs Windows containers, not compatible with our Linux Dockerfile"

      - name: "Test 5: Docker detection functions"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          
          if (Test-DockerInstalled) {
            Write-Host "‚úì Test-DockerInstalled correctly detects Docker"
          } else {
            Write-Host "‚úó Test-DockerInstalled failed"
            exit 1
          }
          
          if (Test-ComposeAvailable) {
            Write-Host "‚úì Test-ComposeAvailable correctly detects Docker Compose"
          } else {
            Write-Host "‚úó Test-ComposeAvailable failed"
            exit 1
          }
          
          # Note: Docker daemon IS running on Windows runners, but with Windows containers
          Write-Host "Docker daemon status: $(Test-DockerRunning)"

      # ----------------------------------------
      # Cursor Installation Test
      # ----------------------------------------
      - name: "Test 6: Install Cursor via WinGet"
        shell: pwsh
        run: |
          Write-Host "==> Installing Cursor IDE via WinGet..."
          
          # Correct package ID: Anysphere.Cursor
          # Reference: https://winstall.app/apps/Anysphere.Cursor
          winget install -e --id Anysphere.Cursor --accept-source-agreements --accept-package-agreements
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "‚úì Cursor installed via WinGet"
          } else {
            Write-Host "‚úó Cursor installation failed"
            exit 1
          }

      - name: "Test 7: Verify Cursor detection after install"
        shell: pwsh
        run: |
          . .\scripts\utils.ps1
          . .\scripts\install-cursor-windows.ps1
          
          Write-Host "==> Testing Cursor detection after install..."
          
          # Check if Cursor is detected
          if (Test-CursorInstalled) {
            Write-Host "‚úì Test-CursorInstalled correctly detects Cursor"
          } else {
            Write-Host "‚úó Test-CursorInstalled failed to detect Cursor"
            exit 1
          }
          
          # Test the Get-CursorPath function
          $path = Get-CursorPath
          if ($path) {
            Write-Host "‚úì Cursor found at: $path"
          } else {
            Write-Host "‚ö† Get-CursorPath returned null (may need PATH refresh)"
          }

      - name: "Test 8: Dev helper commands"
        shell: pwsh
        run: |
          cd windows
          .\dev.ps1 help
          Write-Host "‚úì Dev help command works"

  # ============================================
  # Summary Job
  # ============================================
  test-summary:
    name: ‚úÖ All Tests Passed
    needs: [test-linux, test-macos, test-windows]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Check results
        run: |
          if [ "${{ needs.test-linux.result }}" != "success" ]; then
            echo "‚ùå Linux tests failed"
            exit 1
          fi
          if [ "${{ needs.test-macos.result }}" != "success" ]; then
            echo "‚ùå macOS tests failed"
            exit 1
          fi
          if [ "${{ needs.test-windows.result }}" != "success" ]; then
            echo "‚ùå Windows tests failed"
            exit 1
          fi
          echo "‚úÖ All platform tests passed!"

